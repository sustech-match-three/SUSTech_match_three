package controller;

import listener.GameListener;
import model.*;
import view.CellComponent;
import view.ChessComponent;
import view.ChessboardComponent;

import javax.swing.*;
import javax.swing.Timer;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import java.util.List;

/**
 * Controller is the connection between model and view,
 * when a Controller receive a request from a view, the Controller
 * analyzes and then hands over to the model for processing
 * [in this demo the request methods are onPlayerClickCell() and
 * onPlayerClickChessPiece()]
 */
public class GameController implements GameListener {

    private Chessboard model;
    private ChessboardComponent view;
    // Record whether there is a selected piece before
    private ChessboardPoint selectedPoint1;
    private ChessboardPoint selectedPoint2;

    private boolean canSelectPieces = true;

    public int score=0;
    public int step=10;
    public int difficultyLevel=1;
    public int targetScore=100;

    public int shuffleTime = 0;

    public int promptTime = 0;



    public Level gameLevel = new Level(1);
    private JLabel scoreLabel;
    private JLabel stepLabel;
    private JLabel difficultyLevelLabel;
    private JLabel targetScoreLabel;

    private JLabel shuffleTimeLabel;
    private JLabel promptTimeLabel;

    private boolean isAutoMode = true;
    private boolean isCrazyMode = false;

    private String theme = "Christmas";

    public void setDifficultyLevelLabel(JLabel difficultyLevelLabel) {
        this.difficultyLevelLabel = difficultyLevelLabel;
    }

    public void setTargetScoreLabel(JLabel targetScoreLabel) {
        this.targetScoreLabel = targetScoreLabel;
    }

    public JLabel getScoreLabel() {
        return scoreLabel;
    }

    public JLabel getStepLabel() {
        return stepLabel;
    }

    public JLabel getDifficultyLevelLabel() {
        return difficultyLevelLabel;
    }

    public JLabel getTargetScoreLabel() {
        return targetScoreLabel;
    }

    public JLabel getShuffleTimeLabel() {
        return shuffleTimeLabel;
    }

    public JLabel getPromptTimeLabel() {
        return promptTimeLabel;
    }

    public ChessboardComponent getView() {
        return view;
    }

    public void setStepLabel(JLabel stepLabel) {
        this.stepLabel = stepLabel;
    }

    public void setShuffleTimeLabel(JLabel shuffleTimeLabel) {
        this.shuffleTimeLabel = shuffleTimeLabel;
    }

    public void setPromptTimeLabel(JLabel promptTimeLabel) {
        this.promptTimeLabel = promptTimeLabel;
    }

    public void setScoreLabel(JLabel scoreLabel) {
        this.scoreLabel = scoreLabel;
    }

    public void setAutoMode(boolean isAutoMode) {
        this.isAutoMode = isAutoMode;
    }

    public void setStep(int step) {
        this.step = step;
        stepLabel.setText("Steps: " + step);
        view.repaint();
    }

    public String getTheme() {
        return theme;
    }

    public void setTheme(String theme) {
        this.theme = theme;
    }

    public void setCrazyMode(boolean crazyMode) {
        isCrazyMode = crazyMode;
    }

    public void setGameLevel(Level gameLevel) {
        this.gameLevel = gameLevel;
        this.difficultyLevel = gameLevel.getDifficultyLevel();
        this.step = gameLevel.getMoveLimit();
        this.targetScore = gameLevel.getTargetScore();
        scoreLabel.setText("Score: " + score);
        stepLabel.setText("Steps: " + step);
        difficultyLevelLabel.setText("Level: " + difficultyLevel);
        targetScoreLabel.setText("Target: " + targetScore);
    }


    public Level getGameLevel() {
        return gameLevel;
    }

    public GameController(ChessboardComponent view, Chessboard model) {
        this.view = view;
        this.model = model;
        view.registerController(this);
        view.initiateChessComponent(model);
        view.repaint();
    }

    public void initialize() {
        for (int i = 0; i < Constant.CHESSBOARD_ROW_SIZE.getNum(); i++) {
            for (int j = 0; j < Constant.CHESSBOARD_COL_SIZE.getNum(); j++) {
                model = new Chessboard(theme);
//                model.getGrid()[i][j].setPiece(new ChessPiece(Util.RandomPick(new String[]{"\uD83E\uDDBF", "‚ö™", "‚ñ≤", "üî∂", "\uD83D\uDD3B"})));
                model.getGrid()[i][j].setPiece(new ChessPiece( Util.RandomPick(Util.getThemePieces(theme).toArray(new String[0]))));
                view.removeAllChessComponentsAtGrids();
                view.initiateChessComponent(model);
                view.repaint();
            }
        }
    }


    public void startNewGame() {
        // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
        this.score = 0;
        this.step = gameLevel.getMoveLimit();
        this.difficultyLevel = gameLevel.getDifficultyLevel();
        this.targetScore = gameLevel.getTargetScore();
        this.shuffleTime = 0;
        this.promptTime = 0;
        canSelectPieces = true;

        // Êõ¥Êñ∞ÊòæÁ§∫ÁöÑÂàÜÊï∞ÂíåÊ≠•Êï∞
        scoreLabel.setText("Score: " + score);
        stepLabel.setText("Steps: " + step);
        difficultyLevelLabel.setText("Level: " + difficultyLevel);
        targetScoreLabel.setText("Target: " + targetScore);
        shuffleTimeLabel.setText("Shuffles: " + (3-this.shuffleTime));
        promptTimeLabel.setText("Prompts: " + (5-this.promptTime));

        // ÈáçÁΩÆÊ£ãÁõò
        model.resetBoard(theme);  // ÂÅáËÆæ Chessboard Á±ªÊúâ‰∏Ä‰∏™ÊñπÊ≥ïÊù•ÈáçÁΩÆÊ£ãÁõò
        view.removeAllChessComponentsAtGrids();
        view.initiateChessComponent(model);
        view.repaint();

    }
    public void shuffleGame(){
        if (this.shuffleTime < 3){
            this.initialize();
            this.shuffleTime++;
            this.canSelectPieces = true;
            this.shuffleTimeLabel.setText("Shuffles: " + (3-this.shuffleTime));
        }else {
            JOptionPane.showMessageDialog(null, "No shuffle attempts", "Notice", JOptionPane.INFORMATION_MESSAGE);
        }
    }


    // click an empty cell



    private void removeMatchedPieces(List<ChessboardPoint> matches) {
        for (ChessboardPoint point : matches) {
            // ‰ªéÊ®°Âûã‰∏≠ÁßªÈô§Ê£ãÂ≠ê
            if (isCrazyMode){
                if (model.getChessPieceAt(point) != null){
                    String pieceName = model.getChessPieceAt(point).getName();
                    if (pieceName.equals("üîã")){
                        this.setStep(this.step + 2);
                    }else if (pieceName.equals("üí£")){
                        removeSurroundingPieces(point);
                    }
                }
            }

            model.removePieceAt(point);

            // ‰ªéËßÜÂõæ‰∏≠ÁßªÈô§Áõ∏Â∫îÁöÑÊ£ãÂ≠êÁªÑ‰ª∂
            view.removeChessComponentAtGrid(point);
            view.repaint();
        }
    }

    private void removeSurroundingPieces(ChessboardPoint bombPoint) {
        int row = bombPoint.getRow();
        int col = bombPoint.getCol();
        for (int i = row - 1; i <= row + 1; i++) {
            for (int j = col - 1; j <= col + 1; j++) {
                if (i >= 0 && i < model.getRow() && j >= 0 && j < model.getCol()) {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÁÇπÂπ∂ÁßªÈô§
                    model.removePieceAt(new ChessboardPoint(i, j));
                    view.removeChessComponentAtGrid(new ChessboardPoint(i, j));
                }
            }
        }
    }

    public ArrayList<Match> getMatches(ChessboardPoint point, List<ChessboardPoint> chessboardPoints){
        Match rowMatch = new Match();
        Match colMatch = new Match();
        colMatch.addPoint(point);
        rowMatch.addPoint(point);
        for (int y = 1; point.getCol() + y < model.getCol(); y++) {
            ChessboardPoint t1 = new ChessboardPoint(point.getRow(), point.getCol() + y);
            if (chessboardPoints.contains(t1))
                rowMatch.addPoint(t1);
            else break;
        }
        for (int y = 1; point.getCol() - y > 0; y++) {
            ChessboardPoint t1 = new ChessboardPoint(point.getRow(), point.getCol() - y);
            if (chessboardPoints.contains(t1))
                rowMatch.addPoint(t1);
            else break;
        }

        for (int x = 1; point.getRow() + x < model.getRow(); x++) {
            ChessboardPoint t1 = new ChessboardPoint(point.getRow() + x, point.getCol());
            if (chessboardPoints.contains(t1))
                colMatch.addPoint(t1);
            else break;
        }
        for (int x = 1; point.getRow() - x > 0; x++) {
            ChessboardPoint t1 = new ChessboardPoint(point.getRow() - x, point.getCol());
            if (chessboardPoints.contains(t1))
                colMatch.addPoint(t1);
            else break;
        }
        ArrayList<Match> matches = new ArrayList<>();
        if (rowMatch.getSize() >= 3)
            matches.add(rowMatch);
        if (colMatch.getSize() >= 3)
            matches.add(colMatch);
        return matches;

    }
    private int calculateScore(List<ChessboardPoint> matches) {
        // Ê†πÊçÆÂåπÈÖçÁöÑÊï∞ÈáèËÆ°ÁÆóÂàÜÊï∞
        // ‰æãÂ¶ÇÔºöÊØè‰∏™ÂåπÈÖç 30 ÂàÜ
        int score = 0;
        HashSet<Match> matchesAll = new HashSet<>();
        for (int i = 0; i < matches.size(); i++) {
            ArrayList<Match> res = getMatches(matches.get(i), matches);
            matchesAll.addAll(res);
        }
        for (Match m:matchesAll){
            score += m.getSize() * 10;
            if (isCrazyMode) {
                score += (100 * containsBomb(m));
            }
        }
        return score;
    }

    private int containsBomb(Match match) {
        int cnt = 0;
        for (ChessboardPoint point : match.getPoints()) {
            String pieceName = model.getChessPieceAt(point).getName();
            if (pieceName.equals("üí£")) {
                cnt++;
            }
        }
        return cnt;
    }

    private void handleAutoMode() {
        Runnable autoModeAction = () -> {
            if (detectAndHandleMatches()) {
                dropPiecesWithDelay(this::handleAutoMode); // Â¶ÇÊûúÊúâÂåπÈÖçÔºåÁªßÁª≠‰∏ãËêΩÂπ∂ÈáçÂ§çÊ£ÄÊü•
            } else {
//                System.out.println(" fill empty");
                fillEmptyCellsAndCheckMatches(); // Ê≤°ÊúâÊõ¥Â§öÂåπÈÖçÊó∂Â°´ÂÖÖÁ©∫ÁôΩÂπ∂ÂÜçÊ¨°Ê£ÄÊü•ÂåπÈÖç
            }
        };
        SwingUtilities.invokeLater(autoModeAction); // Âú®‰∫ã‰ª∂Ë∞ÉÂ∫¶Á∫øÁ®ã‰∏äÊâßË°å
    }

    private void fillEmptyCellsAndCheckMatches() {
//        System.out.println("fill in function");
        ArrayList<Point> points = model.fillEmptyCells(theme);
        // Â°´ÂÖÖÁ©∫ÁôΩ‰ΩçÁΩÆ
        view.viewEmptyCells(model, points);
        view.repaint();
//        model.fillEmptyCells();
        // Ê£ÄÊü•ÊòØÂê¶ÊúâÊñ∞ÁöÑÂåπÈÖç

        // ÂàõÂª∫‰∏Ä‰∏™ 500 ÊØ´ÁßíÔºà0.5 ÁßíÔºâÂª∂ËøüÁöÑ Timer
        Timer timer = new Timer(500, e -> {
            if (!detectAndHandleMatches()) {
                ((Timer) e.getSource()).stop();
                // Âú®Ê≤°ÊúâÊõ¥Â§öÂåπÈÖçÊó∂Ê£ÄÊü•Ê∏∏ÊàèÁä∂ÊÄÅ
                checkGameStatus();

            } else {
                // Â¶ÇÊûúËøòÊúâÂåπÈÖçÔºåÁªßÁª≠‰∏ãËêΩÂπ∂Ê£ÄÊü•
                dropPiecesWithDelay(this::fillEmptyCellsAndCheckMatches);
            }
        });
        timer.setRepeats(false); // Á°Æ‰øù Timer Âè™ÊâßË°å‰∏ÄÊ¨°
        timer.start(); // ÂêØÂä® Timer
        // Â¶ÇÊûúÊ≤°ÊúâÊõ¥Â§öÂåπÈÖçÔºåÊ∏∏ÊàèÁªßÁª≠Á≠âÂæÖÁé©ÂÆ∂Êìç‰Ωú
    }

    private boolean detectAndHandleMatches() {
        List<ChessboardPoint> matches = detectMatches();
        HashSet<Match> matchesAll = new HashSet<>();
        for (int i = 0; i < matches.size(); i++) {
            ArrayList<Match> res = getMatches(matches.get(i), matches);
            matchesAll.addAll(res);
        }
        if (!matches.isEmpty()) {
            updateScore(calculateScore(matches));
            removeMatchedPieces(matches);
            if (isCrazyMode){
                for (Match match : matchesAll) {
                    if (match.getSize() == 5) {
                        ChessboardPoint middlePoint = getMiddlePoint(match);
                        model.getGrid()[middlePoint.getRow()][middlePoint.getCol()].setPiece(new ChessPiece(Util.RandomPick(new String[]{"üí£", "üîã"})));
                        ArrayList<Point> t = new ArrayList<>();
                        t.add(new Point(middlePoint.getRow(), middlePoint.getCol()));
                        view.viewEmptyCells(model, t);
//                        placeSpecialPiece(middlePoint, "üí£"); // Êàñ "üîã"ÔºåÂèñÂÜ≥‰∫éÊÇ®ÁöÑËÆæËÆ°
                    } else if (match.getSize() == 4 && Math.random() < 0.50) {
                        // Â§ÑÁêÜÂõõ‰∏™ÂåπÈÖçÁöÑÊÉÖÂÜµÔºåÊúâ 20% Âá†ÁéáÁîüÊàêÁÇ∏ÂºπÊàñÁîµÊ∫ê
                        ChessboardPoint randomPoint = Util.RandomPick(match.getPoints().toArray(new ChessboardPoint[0]));
                        model.getGrid()[randomPoint.getRow()][randomPoint.getCol()].setPiece(new ChessPiece(Util.RandomPick(new String[]{"üí£", "üîã"})));
                        ArrayList<Point> t = new ArrayList<>();
                        t.add(new Point(randomPoint.getRow(), randomPoint.getCol()));
                        view.viewEmptyCells(model, t);
                    }
                }
            }
            return true;
        }
        return false;
    }

    private ChessboardPoint getMiddlePoint(Match match) {
        int sumRow = 0;
        int sumCol = 0;
        for (ChessboardPoint point : match.getPoints()) {
            sumRow += point.getRow();
            sumCol += point.getCol();
        }
        int middleRow = sumRow / match.getPoints().size();
        int middleCol = sumCol / match.getPoints().size();
        return new ChessboardPoint(middleRow, middleCol);
    }

    private void dropPiecesWithDelay(Runnable onComplete) {
        Timer timer = new Timer(500, e -> {
            if (!dropPieces()) {
                ((Timer) e.getSource()).stop();
                onComplete.run();
            }
        });
        timer.setRepeats(true);
        timer.start();
    }


    private void updateScore(int scoreEarned) {
        // Êõ¥Êñ∞Ê∏∏ÊàèÂàÜÊï∞
        this.score += scoreEarned;
        this.scoreLabel.setText("Score:" + score);
        this.stepLabel.setText("Step: " + step);
    }

    private void updateBoard() {
        // Âú®ËßÜÂõæ‰∏äÊõ¥Êñ∞Ê£ãÁõòÔºå‰æãÂ¶ÇÈáçÁªòÊàñÈáçÊñ∞Â∏ÉÂ±ÄÊ£ãÂ≠ê
        view.repaint();
        // ÂèØËÉΩËøòÈúÄË¶ÅÂ§ÑÁêÜÊ£ãÂ≠êÁöÑ‰∏ãËêΩÈÄªËæë
    }

    public boolean dropPieces() {
        boolean res = false;
        for (int col = 0; col < model.getCol(); col++) {
            for (int row = model.getRow() - 1; row >= 0; row--) {
                ChessboardPoint point1 = new ChessboardPoint(row, col);
                ChessboardPoint point2 = new ChessboardPoint(row-1, col);
                ChessPiece currentPiece = model.getChessPieceAt(point1);
                if (currentPiece == null) {
                    if (model.getChessPieceAt(point2) != null)
                        res = true;
                    // ÊâæÂà∞Á©∫‰ΩçÔºåÂ∞Ü‰∏äÊñπÊ£ãÂ≠ê‰∏ãÁßª
                    model.swapChessPiece(point1, point2);
                    ChessComponent chess1 = view.removeChessComponentAtGrid(point2);
                    ChessComponent chess2 = view.removeChessComponentAtGrid(point1);
                    view.setChessComponentAtGrid(point2, chess2);// TODO: Init your swap function here.
                    view.setChessComponentAtGrid(point1, chess1);
                    if (chess1!=null)
                        chess1.repaint();
                    if (chess2!=null)
                        chess2.repaint();
                }
                view.repaint();
            }
        }

        return res;
    }

    public boolean startDroppingPieces() {
        boolean res = dropPieces();
        // ÂàõÂª∫‰∏Ä‰∏™ 500 ÊØ´ÁßíÔºà0.5 ÁßíÔºâÂª∂ËøüÁöÑ Timer
        Timer timer = new Timer(500, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                boolean result = dropPieces();
                if (!result) {
                    // Â¶ÇÊûú dropPieces ËøîÂõû falseÔºåÂàôÂÅúÊ≠¢ Timer
                    ((Timer) e.getSource()).stop();
                    afterDroppingPieces();
                }
                // Â¶ÇÊûúËøîÂõû trueÔºåTimer Â∞ÜÁªßÁª≠ËøêË°åÂπ∂ÂÜçÊ¨°Ë∞ÉÁî® dropPieces
            }
        });


        timer.start(); // ÂêØÂä® Timer

        return res;
    }

    public void afterDroppingPieces() {
        List<ChessboardPoint> matches = detectMatches();
        if (!matches.isEmpty()) {
            if (isAutoMode) {
                // Ëá™Âä®Ê®°Âºè‰∏ãÁöÑÈÄªËæë
            } else {
                // ËÆ°ÁÆóÂπ∂Êõ¥Êñ∞ÂàÜÊï∞
                int scoreEarned = calculateScore(matches);
                updateScore(scoreEarned);

                // ÊâãÂä®Ê®°Âºè‰∏ãÁ≠âÂæÖÁé©ÂÆ∂Ëøõ‰∏ÄÊ≠•Êìç‰Ωú
                removeMatchedPieces(matches);



                // Êõ¥Êñ∞Ê£ãÁõòÁïåÈù¢
                updateBoard();
            }
        }
        // ÂÖ∂‰ªñÂèØËÉΩÁöÑÂêéÁª≠Êìç‰Ωú
    }

    private List<ChessboardPoint> detectMatches() {
//        List<ChessboardPoint> matchedPoints = new ArrayList<>();
        Set<ChessboardPoint> matchedPoints = new HashSet<>();
        // ‰ΩøÁî® chessboard.isMatch ÊñπÊ≥ïÊ£ÄÊü•ÂåπÈÖç
        // Á§∫‰æãÔºöÊ£ÄÊü•Ê∞¥Âπ≥ÊñπÂêëÁöÑÂåπÈÖç
        for (int row = 0; row < model.getRow(); row++) {
            for (int col = 0; col < model.getCol() - 2; col++) {
                if (model.isMatch(row, col, row, col + 1, row, col + 2)) {
                    matchedPoints.add(new ChessboardPoint(row, col));
                    matchedPoints.add(new ChessboardPoint(row, col + 1));
                    matchedPoints.add(new ChessboardPoint(row, col + 2));
                }
            }
        }
        // Ê£ÄÊü•ÂûÇÁõ¥ÊñπÂêëÁöÑÂåπÈÖç
        for (int col = 0; col < model.getRow(); col++) {
            for (int row = 0; row < model.getCol() - 2; row++) {
                if (model.isMatch(row, col, row + 1, col, row + 2, col)) {
                    matchedPoints.add(new ChessboardPoint(row, col));
                    matchedPoints.add(new ChessboardPoint(row + 1, col));
                    matchedPoints.add(new ChessboardPoint(row + 2, col));
                }
            }
        }

        // ÈáçÂ§ç‰ª•‰∏äÈÄªËæëÊ£ÄÊü•ÂûÇÁõ¥ÊñπÂêëÁöÑÂåπÈÖç
        // ...

        return new ArrayList<>(matchedPoints);
    }

    public boolean isDead() {
        for (int row = 0; row < model.getRow(); row++) {
            for (int col = 0; col < model.getCol(); col++) {
                if (canSwapLeadToMatch(row, col, row, col + 1) || canSwapLeadToMatch(row, col, row + 1, col)) {
                    return false; // Â¶ÇÊûú‰ªª‰∏Ä‰∫§Êç¢ÂèØ‰ª•‰∫ßÁîüÂåπÈÖçÔºåÂàô‰∏çÊòØÊ≠ªÂ±Ä
                }
            }
        }
        return true; // Â¶ÇÊûúÊ≤°Êúâ‰∫§Êç¢ÂèØ‰ª•‰∫ßÁîüÂåπÈÖçÔºåÈÇ£‰πàÊòØÊ≠ªÂ±Ä
    }

    private boolean canSwapLeadToMatch(int row1, int col1, int row2, int col2) {
        if (isValidSwap(row1, col1, row2, col2)) {
            model.swapChessPiece(new ChessboardPoint(row1, col1), new ChessboardPoint(row2, col2));
            boolean hasMatch = !detectMatches().isEmpty();
            model.swapChessPiece(new ChessboardPoint(row1, col1), new ChessboardPoint(row2, col2)); // Êç¢ÂõûÂéü‰Ωç
            return hasMatch;
        }
        return false;
    }

    private boolean isValidSwap(int row1, int col1, int row2, int col2) {
        // È™åËØÅÊ£ãÂ≠êÊòØÂê¶Âú®Ê£ãÁõòËåÉÂõ¥ÂÜÖ
        if (!isWithinBoard(row1, col1) || !isWithinBoard(row2, col2)) {
            return false;
        }

        // Ê£ÄÊü•‰∏§‰∏™Ê£ãÂ≠êÊòØÂê¶Áõ∏ÈÇª
        return Math.abs(row1 - row2) + Math.abs(col1 - col2) == 1;
    }

    private boolean isWithinBoard(int row, int col) {
        return row >= 0 && row < model.getRow() && col >= 0 && col < model.getCol();
    }

    public void checkGameStatus() {
        boolean isDead = isDead();
        if (score >= targetScore) {
            // Ê∏∏ÊàèËÉúÂà©
            int response = JOptionPane.showConfirmDialog(null,
                    "Congratulations! You've won! Do you want to proceed to the next level?",
                    "Game Over", JOptionPane.YES_NO_OPTION);

            if (response == JOptionPane.YES_OPTION) {
                // Áé©ÂÆ∂ÈÄâÊã©ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥
                goToNextLevel();
            }
            // Â¶ÇÊûúÁé©ÂÆ∂ÈÄâÊã©Âê¶ÔºåÊàñËÄÖÂÖ≥Èó≠ÂºπÁ™óÔºåÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Â§ÑÁêÜÈÄªËæë

        } else if (step <= 0 || (isDead && this.shuffleTime>=3)) {
            // Ê∏∏ÊàèÂ§±Ë¥•
            JOptionPane.showMessageDialog(null,
                    "Game Over! You've run out of steps!",
                    "Game Over", JOptionPane.INFORMATION_MESSAGE);
        }
        if (isDead){
            JOptionPane.showMessageDialog(null, "You need to shuffle chessboard", "Notice", JOptionPane.INFORMATION_MESSAGE);
        }
        canSelectPieces = true;
    }

    private void goToNextLevel() {
        // Â¢ûÂä†ÈöæÂ∫¶Á∫ßÂà´
        int nextLevel = difficultyLevel + 1;
        gameLevel = new Level(nextLevel);
        startNewGame(); // ÂÅáËÆæ Level Á±ªÂèØ‰ª•Êé•Âèó‰∏Ä‰∏™Êï¥Êï∞‰Ωú‰∏∫ÈöæÂ∫¶Á≠âÁ∫ß
    }

    public ChessboardPoint[] findBestSwap() {
        int maxScore = 0;
        ChessboardPoint[] bestSwap = new ChessboardPoint[2];

        for (int row = 0; row < model.getRow(); row++) {
            for (int col = 0; col < model.getCol(); col++) {
                // Â∞ùËØï‰∏éÂè≥‰æßÂíå‰∏ãÊñπÁöÑÊ£ãÂ≠ê‰∫§Êç¢
                if (col + 1 < model.getCol()) { // Á°Æ‰øù‰∏çË∂ÖÂá∫Ê£ãÁõòËæπÁïå
                    int score = simulateSwapAndCalculateScore(row, col, row, col + 1);
                    if (score > maxScore) {
                        maxScore = score;
                        bestSwap[0] = new ChessboardPoint(row, col);
                        bestSwap[1] = new ChessboardPoint(row, col + 1);
                    }else if (score == maxScore){
                        if (bestSwap[0] != null && bestSwap[0].getRow() + bestSwap[1].getRow() < row *2){
                            bestSwap[0] = new ChessboardPoint(row, col);
                            bestSwap[1] = new ChessboardPoint(row, col + 1);
                        }
                    }
                }
                if (row + 1 < model.getRow()) { // Á°Æ‰øù‰∏çË∂ÖÂá∫Ê£ãÁõòËæπÁïå
                    int score = simulateSwapAndCalculateScore(row, col, row + 1, col);
                    if (score > maxScore) {
                        maxScore = score;
                        bestSwap[0] = new ChessboardPoint(row, col);
                        bestSwap[1] = new ChessboardPoint(row + 1, col);
                    }else if (score == maxScore){
                        if (bestSwap[0] != null && bestSwap[0].getRow() + bestSwap[1].getRow() < row * 2 + 1){
                            bestSwap[0] = new ChessboardPoint(row, col);
                            bestSwap[1] = new ChessboardPoint(row + 1, col);
                        }
                    }
                }
            }
        }
        return bestSwap; // ËøîÂõûÂæóÂàÜÊúÄÈ´òÁöÑ‰∫§Êç¢‰ΩçÁΩÆ
    }


    private int simulateSwapAndCalculateScore(int row1, int col1, int row2, int col2) {
        // Á°Æ‰øùËøôÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑ‰∫§Êç¢
        if (!isValidSwap(row1, col1, row2, col2)) return 0;

        // Ê®°Êãü‰∫§Êç¢
        model.swapChessPiece(new ChessboardPoint(row1, col1), new ChessboardPoint(row2, col2));

        // Ê£ÄÊµãÂåπÈÖçÂπ∂ËÆ°ÁÆóÂàÜÊï∞
        List<ChessboardPoint> matches = detectMatches();
        int score = calculateScore(matches);

        // Â∞ÜÊ£ãÂ≠êÊç¢ÂõûÂéü‰Ωç
        model.swapChessPiece(new ChessboardPoint(row1, col1), new ChessboardPoint(row2, col2));

        return score;
    }

    public void makeCellsBlink(ChessboardPoint point1, ChessboardPoint point2) {
        CellComponent cell1 = view.getCellComponentAt(point1);
        CellComponent cell2 = view.getCellComponentAt(point2);

        // ÂÆö‰πâÈó™ÁÉÅÂë®ÊúüÂíåÊåÅÁª≠Êó∂Èó¥
        int delay = 300; // Èó™ÁÉÅÈó¥ÈöîÔºàÊØ´ÁßíÔºâ
        long startTime = System.currentTimeMillis();
        long duration = 2000; // Èó™ÁÉÅÊÄªÊó∂ÈïøÔºàÊØ´ÁßíÔºâ

        Timer timer = new Timer(delay, null);
        timer.addActionListener(e -> {
            if (System.currentTimeMillis() - startTime > duration) {
                // ÂÅúÊ≠¢Èó™ÁÉÅÂπ∂ÊÅ¢Â§çÊ≠£Â∏∏Â§ñËßÇ
                cell1.restoreNormalAppearance();
                cell2.restoreNormalAppearance();
                timer.stop();
            } else {
                // ÂàáÊç¢Èó™ÁÉÅÂ§ñËßÇ
                cell1.toggleBlinkAppearance();
                cell2.toggleBlinkAppearance();
            }
        });
        timer.start();
    }

    public void prompt() {
        if (promptTime<5){
            ChessboardPoint[] bestSwapPoints = findBestSwap();
            if (bestSwapPoints[0] != null && bestSwapPoints[1] != null) {
                makeCellsBlink(bestSwapPoints[0], bestSwapPoints[1]);
                this.promptTime++;
                this.promptTimeLabel.setText("Prompts: " + (5-this.promptTime));
            }
            view.repaint();
        }else {
            JOptionPane.showMessageDialog(null, "No prompt attempts", "Notice", JOptionPane.INFORMATION_MESSAGE);
        }
    }



    @Override
    public void onPlayerClickCell(ChessboardPoint point, CellComponent component) {

    }

    @Override
    public void onPlayerSwapChess() {
        if (!isAutoMode)
            step--;//score‰Ω†ÂÜçË°•ÂÖÖ‰∏Ä‰∏ã
        if (selectedPoint1 != null && selectedPoint2 != null) {
            canSelectPieces = false;

            // ‰∫§Êç¢Ê£ãÂ≠ê
            model.swapChessPiece(selectedPoint1, selectedPoint2);
            ChessComponent chess1 = view.removeChessComponentAtGrid(selectedPoint2);
            ChessComponent chess2 = view.removeChessComponentAtGrid(selectedPoint1);
            view.setChessComponentAtGrid(selectedPoint2, chess2);// TODO: Init your swap function here.
            view.setChessComponentAtGrid(selectedPoint1, chess1);
            chess1.repaint();
            chess2.repaint();
            // ÂàõÂª∫‰∏Ä‰∏™ 500 ÊØ´ÁßíÔºà0.5 ÁßíÔºâÂª∂ËøüÁöÑ Timer
            Runnable delayedAction = () -> {
                // ÊâßË°å‰∏Ä‰∫õÊìç‰Ωú...
                List<ChessboardPoint> matches = detectMatches();
                if (!matches.isEmpty()) {
                    // Â¶ÇÊûúÊúâÂåπÈÖç
                    if (isAutoMode) {
                        // Ëá™Âä®Ê®°Âºè‰∏ãËá™Âä®Â§ÑÁêÜÂåπÈÖç
                        handleAutoMode();
                    } else {
                        // ËÆ°ÁÆóÂπ∂Êõ¥Êñ∞ÂàÜÊï∞
                        int scoreEarned = calculateScore(matches);
                        updateScore(scoreEarned);

                        // ÊâãÂä®Ê®°Âºè‰∏ãÁ≠âÂæÖÁé©ÂÆ∂Ëøõ‰∏ÄÊ≠•Êìç‰Ωú
                        removeMatchedPieces(matches);

                        // Êõ¥Êñ∞Ê£ãÁõòÁïåÈù¢
                        updateBoard();
                    }

                } else {
                    // Â¶ÇÊûúÊ≤°ÊúâÂåπÈÖçÔºåÈÄöÁü•Áé©ÂÆ∂
                    // ËøôÈáåÂèØ‰ª•ÈÄâÊã©ÊòØÂê¶Â∞ÜÊ£ãÂ≠êÊç¢ÂõûÂéü‰Ωç
                    model.swapChessPiece(selectedPoint1, selectedPoint2);
                    ChessComponent chess3 = view.removeChessComponentAtGrid(selectedPoint2);
                    ChessComponent chess4 = view.removeChessComponentAtGrid(selectedPoint1);
                    view.setChessComponentAtGrid(selectedPoint2, chess4);// TODO: Init your swap function here.
                    view.setChessComponentAtGrid(selectedPoint1, chess3);
                    chess3.repaint();
                    chess4.repaint();
                    if (!isAutoMode)
                        JOptionPane.showMessageDialog(null, "Illegal Swap", "Notice", JOptionPane.INFORMATION_MESSAGE);
                    canSelectPieces = true;

                }
                selectedPoint1 = null;
                selectedPoint2 = null;

            };
            Timer timer = new Timer(500, e -> {
                delayedAction.run(); // Âª∂ËøüÁªìÊùüÂêéÊâßË°åÊìç‰Ωú
                ((Timer) e.getSource()).stop(); // ÂÅúÊ≠¢ Timer
            });
            timer.setRepeats(false); // Á°Æ‰øù Timer Âè™ÊâßË°å‰∏ÄÊ¨°
            timer.start(); // ÂêØÂä® Timer
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂåπÈÖç

        } else {
            // Â¶ÇÊûúÊ≤°Êúâ‰∏§‰∏™Ê£ãÂ≠êË¢´ÈÄâ‰∏≠ÔºåÈÄöÁü•Áé©ÂÆ∂
//            System.out.println("Not select two pieces");
            JOptionPane.showMessageDialog(null, "Not select two pieces", "Notice", JOptionPane.INFORMATION_MESSAGE);
            canSelectPieces = true;
        }
    }


    @Override
    public void onPlayerNextStep() {
        // TODO: Init your next step function here.
        if (startDroppingPieces()){

        }else {
//            System.out.println("new");
            ArrayList<Point> points = model.fillEmptyCells(theme);
            view.viewEmptyCells(model, points);
            view.repaint();
            this.afterDroppingPieces();
            checkGameStatus();
        }

    }

    // click a cell with a chess
    @Override
    public void onPlayerClickChessPiece(ChessboardPoint point, ChessComponent component) {
        if (canSelectPieces){
            if (selectedPoint2 != null) {
                int distance2point1 = Math.abs(selectedPoint1.getCol() - point.getCol()) + Math.abs(selectedPoint1.getRow() - point.getRow());
                int distance2point2 = Math.abs(selectedPoint2.getCol() - point.getCol()) + Math.abs(selectedPoint2.getRow() - point.getRow());
                ChessComponent point1 = (ChessComponent) view.getGridComponentAt(selectedPoint1).getComponent(0);
                ChessComponent point2 = (ChessComponent) view.getGridComponentAt(selectedPoint2).getComponent(0);
                if (distance2point1 == 0 && point1 != null) {
                    point1.setSelected(false);
                    point1.repaint();
                    selectedPoint1 = selectedPoint2;
                    selectedPoint2 = null;
                } else if (distance2point2 == 0 && point2 != null) {
                    point2.setSelected(false);
                    point2.repaint();
                    selectedPoint2 = null;
                } else if (distance2point1 == 1 && point2 != null) {
                    point2.setSelected(false);
                    point2.repaint();
                    selectedPoint2 = point;
                    component.setSelected(true);
                    component.repaint();
                } else if (distance2point2 == 1 && point1 != null) {
                    point1.setSelected(false);
                    point1.repaint();
                    selectedPoint1 = selectedPoint2;
                    selectedPoint2 = point;
                    component.setSelected(true);
                    component.repaint();
                }
                return;
            }


            if (selectedPoint1 == null) {
                selectedPoint1 = point;
                component.setSelected(true);
                component.repaint();
                return;
            }

            int distance2point1 = Math.abs(selectedPoint1.getCol() - point.getCol()) + Math.abs(selectedPoint1.getRow() - point.getRow());

            if (distance2point1 == 0) {
                selectedPoint1 = null;
                component.setSelected(false);
                component.repaint();
                return;
            }

            if (distance2point1 == 1) {
                selectedPoint2 = point;
                component.setSelected(true);
                component.repaint();
            } else {
                selectedPoint2 = null;

                ChessComponent grid = (ChessComponent) view.getGridComponentAt(selectedPoint1).getComponent(0);
                if (grid == null) return;
                grid.setSelected(false);
                grid.repaint();

                selectedPoint1 = point;
                component.setSelected(true);
                component.repaint();
            }
            if (isAutoMode){
                if (selectedPoint1 != null && selectedPoint2 != null){
                    this.onPlayerSwapChess();
                    this.step--;
                }
            }
        }


    }
//
//    public static int computedLeftX(ChessboardPoint point1){
//        int result = 0;
//        int x = point1.getCol();
//        int y = point1.getRow();
//        ChessPiece chessPiece = Chessboard.getChessPieceAt(point1);
//        for (int i = x-1; i>=0; i--) {
//            ChessboardPoint point2 = new ChessboardPoint(y,i);
//            if(chessPiece == Chessboard.getChessPieceAt(point2)){
//                result++;
//            }else{
//                break;
//            }
//        }
//        return result;
//    }//ÂêëÂ∑¶ËæπÂåπÈÖçÊ£ãÂ≠ê
//
//    public static int computedRightX(ChessboardPoint point1){
//        int result = 0;
//        int x = point1.getCol();
//        int y = point1.getRow();
//        ChessPiece chessPiece = Chessboard.getChessPieceAt(point1);
//        for (int i = x+1; i<=; i++) {
//            ChessboardPoint point2 = new ChessboardPoint(y,i);
//            if(chessPiece == Chessboard.getChessPieceAt(point2)){
//                result++;
//            }else{
//                break;
//            }
//        }
//        return result;
//    }//ÂêëÂè≥ËæπÂåπÈÖçÊ£ãÂ≠ê

}
